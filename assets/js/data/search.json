[ { "title": "Compiling HLSL Shaders with Direct3D12 and CMake (With Error Reporting) Part 1", "url": "/posts/COMIPLING_SHADERS_DIRECTD/", "categories": "Computer_Graphics, Direct3D_12", "tags": "cpp, direct3d12, cmake, visual studio", "date": "2022-06-23 22:00:00 +0300", "snippet": "Note: This post is still in progress (don’t worry I am working on it almost everyday, I didn’t abandon it and it will be ready very soon). However, feel free to message me about improving the current draft if you have any ideasWhile learning Direct3D12 and working on my game engine Mizu I found that there are many ways to compile shaders but there is no clear documentation about the different shader compilation ways and how to apply them (especially if you are using CMake as a build system). Therefore, as usual no clear documentation? Time to write a post on this blog1. Getting the intial HelloTriangle projectAs a start I will be using Microsoft’s Hello Triangle example from the D3D12HelloWorld example. Visual Studio is needed of course (I am using 2022 version and 2015, 2017 should work for you as long as you have the suitable windows sdk and you can install the latest one from Visual Studio installer to be sure)I will isolate the HelloTriangle example alone and use CMakeas a build system for that standalone project. You don’t have to do anything but I just wanted to explain how I got to the CMake file in the repository for the code of this post. Also, A true C++ programmer should be familiar with CMake :P Let’s take only the source and header files in HelloTriangle’s folder, put them in a folder called HelloTriangle (for example) and remove everything else. Now we will create a CMakeLists.txt file:project(\"Hello Triangle\")cmake_minimum_required(VERSION 3.21)add_definitions(-D_UNICODE)add_definitions(-DUNICODE)link_libraries(d3d12.libdxguid.libDXGI.libd3dcompiler.lib)set(HelloTriangle1_SOURCESD3D12HelloTriangle.cppDXSample.cppstdafx.cppWin32Application.cpp)set(HelloTriangle1_HEADERSD3D12HelloTriangle.hDXSample.hDXSampleHelper.hstdafx.hWin32Application.h)set(HelloTriangle1_SHADERSshaders.hlsl)set_source_files_properties(shaders.hlsl PROPERTIES VS_TOOL_OVERRIDE \"None\")add_executable(HelloTriangle1 WIN32 Main.cpp ${HelloTriangle1_HEADERS} ${HelloTriangle1_SOURCES} ${HelloTriangle1_SHADERS})target_include_directories(HelloTriangle1 PUBLIC ${CMAKE_CURRENT_LIST_DIR})source_group(\"Shaders\" FILES ${HelloTriangle1_SHADERS})Explaination of the lines: 1 to 2: In any cmake file we should define a project name and the minimum version which the person who is building the project should have. 4 to 5: Because we use wide string aka std::wstring in C++ for Direct3D API, this definition should be added from CMake otherwise we will get errors because the project will not know if you should use ANSI or UNICODE so you should define which one is it for the project More info in this question on StackOverFlow. 7 to 12: We should link to Direct3D libraries but here I just used link_libraries to link to all the libraries and executables because the project is already small and that won’t be an issue here. 14 to 19: Just make a list HelloTriangle1_SOURCES which contains the names of the cpp files. 21 to 27: same as previous point but a list for headers instead. 29 to 31: Making a list for Shader HLSL files (because we wanna tell Visual Studio to include them and treat them in a special way) 33: Visual Studio usually tries to compile the HLSL files in the default way automatically. For example, if we have a Pixel Shader it will detect its type and the HLSL compiler will make sure it is fine and without syntax errors. However, in this case we have put all shaders in one file and the default behaviour will cause compilation errors and settings should be changed. You can change it manually, but in this case you either have to upload the sln file and other related files with it, or you can just add this option in CMake which will make the project settings not using this default behaviour by default and not calling the shader compiler. We will talk about the shader compiler later in this post. 35: We add an executable called HelloTriangle1 with type WIN32 because otherwise it will think it’s an console application by default and the way we write the main function in Direct3D applications will cause compiler errors and not work. Then, we add all our files from the 3 lists (there is no need usually to add headers but I just added everything all together with sources). If you don’t add Shader files in the list of sources given to add_executable, they will not appear in the project in Visual Studio and it will be inconvinent to use another editor or window to modify their code. 37: We make the current CMAKE_CURRENT_LIST_DIR (where the current CMake file is) a directory visible to #include so that we can import our headers in any source file. Again, since the project is small I made everything visible to #include 38: source_group is used to make Visual Studio put the shader files inside a special folder (Shaders in this case) because it will be convinent for organization inside Visual Studio’s solution explorer If you don’t add a source_group for shaders, they will be in the same directory level of source files and header files in Visual Studio’s solution explorer which works of course but feels weird and not organized in an elegant wayNow there are 3 main ways we can use shaders in our Direct3D program: Using D3DCompileFromFile function Let VS automatically do it for us Using the DirectXShaderCompilerWe will talk about the first and second one here (I will reference them here as I write them)if you check the file D3D12HelloTriangle.cpp line number 163 and the one after it, you will see the following:ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L\"../../shaders.hlsl\").c_str(), nullptr, nullptr, \"VSMain\", \"vs_5_0\", compileFlags, 0, &amp;vertexShader, nullptr)); ThrowIfFailed(D3DCompileFromFile(GetAssetFullPath(L\"../../shaders.hlsl\").c_str(), nullptr, nullptr, \"PSMain\", \"ps_5_0\", compileFlags, 0, &amp;pixelShader, nullptr));Here we use the function ThrowIfFailed which throws and exception if the expression inside it returns a failure through its HLRESULT return type. Inside it, we got D3DCompileFromFile with the following signature:HRESULT D3DCompile( [in] LPCVOID pSrcData, [in] SIZE_T SrcDataSize, [in, optional] LPCSTR pSourceName, [in, optional] const D3D_SHADER_MACRO *pDefines, [in, optional] ID3DInclude *pInclude, [in, optional] LPCSTR pEntrypoint, [in] LPCSTR pTarget, [in] UINT Flags1, [in] UINT Flags2, [out] ID3DBlob **ppCode, [out, optional] ID3DBlob **ppErrorMsgs);Where: [in] pFileName: A pointer to a constant null-terminated string that contains the name of the file that contains the shader code. it takes a wide string literall (usually passed like this: L\"content here\"). Here I used GetAssetFullPath function and passed the relative path so that it will return the full path like C:/Junk/shader.hlsl because the compiler takes the full path only (seems project relative one is different from the compiler relative one so GetAssetFullPath results gets evaluated relative to project then it's passed full to compiler. Remember that the compiler is in program files with visual studio compiler somewhere so it's relative folders and files are totally somewhere else). Also, I used .c_str()` in the end because it accepts a literal not a wstring variable so I passed the literal out of the variable. [in, optional] pDefines:An optional array of D3D_SHADER_MACRO structures that define shader macros. Here we don’t need that so we passed nullptr (or you can pass NULL) [in, optional] pInclude:An optional pointer to an ID3DInclude interface that the compiler uses to handle include files. Here we didn’t include any files so we pass nullptr too [in] pEntrypoint:A pointer to a constant null-terminated string that contains the name of the main function of the shader (like int main() in C++ and C but here you don’t have to call it main just tell the compiler where is it) [in] pTarget: A pointer to a constant null-terminated string that specifies the shader target or set of shader features to compile against. So here I passed vs_5_0 to first call to tell the function we wanna use version 5 and this is a vertex shader (vs) and same idea for second one to use the pixel shader (ps). You can check the list of such compiler targets here [in] Flags1:Shader compile options and we can use OR operator between many of them if we wanna use more than one. Full list of such options here. Here we used D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION in case of debug and nothing in case of Release and stored them in compileFlags variable. [in] Flags2:Effect compile options (Effect options here and Compiler options in the ones before them). Full list here. They are not needed here so we passed 0. [out] ppCode:A pointer to a variable that receives a pointer to the ID3DBlob interface that you can use to access the compiled code. So we passed here the reference to ComPtr&lt;ID3DBlob&gt; vertexShader which is &amp;vertexShader. Don’t forget that you have for ComPtr: RelaseAndGetAddressOf()which is the same as &amp; or you can use GetAddressOf() function if you don’t wanna release unlike what we did here because we wanna pass it to store the returned info so it does not matter [out, optional] ppErrorMsgsAn optional pointer to a variable that receives a pointer to the ID3DBlob interface and we can use it to get the compiler error messages. We passed nullptr for now and will show later how it works. I advise you to put it as a good practice to detect errors and understand them easier.To be continued…References: D3DCompileFromFile function Microsoft docs&lt;!—You can find the current project inside this folder in Direct3DExamples repository in this linkHope everything is clear and if you have any feedback feel free to contact me on discord, comment here or email.TODO add advantages and disadvantages of this way and finish the tutorial for nowThanks for reading !–&gt;" }, { "title": "Using Bison C++ API With Hand-written Scanner", "url": "/posts/HAND_WRITTEN_SCANNER_WITH_BISON_Cpp_API/", "categories": "Compilers, Bison", "tags": "Cpp, Bison", "date": "2020-10-24 22:00:00 +0300", "snippet": "In this post, I’ll talk about how can you use Bison’s C++ API. Take a look at the tutorial I wrote about using C API especially the parts about installing Bison latest version and Compiler Construction. Also, to gain more knowledge about how Bison works. Well, as I said in the C API post, you can’t use dynamic types such as std::string or std::vector as Bison types which is one of the reasons of using C++ API (The main reason is that C++ is cooler of course !). Again this tutorial is not focusing on Bison itself, just the C++ API part. We have a simple input file in an imperative language : var some_identifer is integer Now let’s write a simple Scanner in C++ (same idea as the C one) :#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;// I know that global variables are often bad. Forgive me I wanna just explain the idea ((std::ifstream fin;std::string get_next_token(){ std::string s; char c; while (true) { // could be done better but organized it like this to edit only assignments and returns when using Bison API if (!fin.eof()) fin.get(c);// get one character else return \"\"; if (c == ' ' || c == '\\n' || fin.eof()) { if (s.empty()) // we only have this character { if (fin.eof()) return \"\"; //otherwise go and see what's next return get_next_token(); } else { if (!fin.eof()) { // now we need to put the pointer exactly after the word (undo the last step) // NOTE : don't use unget if you reach the end of the file because it will clear eof bit and bad stuff will happen !!! fin.unget(); } if (s == \"var\") // the last word is var return s; if (s == \"integer\") return s; if (s == \"is\") return s; if (!s.empty())// it means it is some identifier name return \"Identifier\"; } } else if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || c == '_') // reading some name { s += c; // add the char to the string } else { // we don't know what's that return \"ERROR\"; } }}int main(){ fin.open(\"input.txt\"); std::string temp = get_next_token(); while (!temp.empty()) { // printing a space since our example is only one line for now std::cout &lt;&lt; temp &lt;&lt; \" \"; temp = get_next_token(); } return 0;} Now the Bison part. (not going to go deep into grammar rules or the way you design them. I learned grammar in Theoretical Computer Science course) but I will talk about the programming aspects. Save the Bison file with .ypp extenstion to make it work properly with a C++ compiler Bison file consists of 4 parts : I. Defines and requirements (statementsstart with % usually). II. C/С++ code part(s) for includes and signatures (will be at the beginning of the generated .h file) III. Grammar part IV. Function defintions’ part Note that in Bison’s C++ API, a class Parser is generated unlike in the C API were we have only functions. Take a look at this Bison with C++ example (I will explain after that) :%require \"3.2\"%language \"C++\"%define api.value.type variant%define api.token.constructor%define parse.assert%code requires{ #pragma once #include &lt;iostream&gt; #include &lt;string&gt; // forward decleration (1) namespace yy { class parser; }}%code{ namespace yy { parser::symbol_type yylex(); // override (2) // no need to override the error function because it is already waiting for our implementation (3) }}%token IDENT VAR INT IS%type &lt;std::string&gt; IDENT%%Program:|Program VariableDeclaration;VariableDeclaration: VAR IDENT IS INT { /* no actions for now (4) */ };%%namespace yy{ parser::symbol_type yylex() { return yy::parser::make_YYEOF (); } void parser::error(const std::string&amp; msg) //(3+) { std::cout&lt;&lt; \"syntax error!\\n\"; }}int main(){ yy::parser p; // (5) // will be deleted later just make sure it prints it std::cout &lt;&lt; \"hello\\n\" &lt;&lt; std::endl; return 0;} First, we are using Bison macros (not sure of their official name) which have % at the beginning of them: Adding a condition about the least version which can be used with the used programming language. Note: As the documentation says, C++ Bison API is pure always so no need to add %define api.pure full as we did in the C API. %define api.value.type variant : As we know in C++, we don’t use unions (you can but the standard doesn’t recommend it usually. You can check this and this question). So now you can directly just write the type of each token without the need to define a union with field names as we did in the C API. %define api.token.constructor: this one will generate functions in our .hpp file for each token which has a type. For example %type &lt;std::string&gt; IDENT generates a constructor : make_IDENT(std::string) (also another one make_IDENT(std::string&amp;)). As a result, we can use it in our scanner later, it will put the string in the parameter in the value which corresponds to our IDENT token and all we have to do is return make_IDENT(string_variable) (in the C API we had to do lval-&gt;s = some_char_array where s is the name of the char array field in our union and then return the token). %define parse.assert seems to help us with useful error messages and warnings according to this doc page : Directive: %define parse.assert Languages(s): C, C++ Purpose: Issue runtime assertions to catch invalid uses. In C, some important invariants in the implementation of the parser are checked when this option is enabled. In C++, when variants are used (see section C++ Variants), symbols must be constructed and destroyed properly. This option checks these constraints using runtime type information (RTTI). Therefore the generated code cannot be compiled with RTTI disabled (via compiler options such as -fno-rtti). Accepted Values: Boolean Default Value: false %code requires block which contains the required things which must be added at the beginning of our .hpp file. For example, we need &lt;string&gt; because in the header file, Bison wants to use it for making the IDENT constructor. (I don’t know if I should add #pragma once or not but just in case).Note in (1) we did forward declreation because we want to override yylex() (as you will see next) which belongs to the class parser while the class definition will be after the overriding. For more info about Forward Decleration read this. We defined yylex() (which belongs to the yy namespace in the C++ API) inside the %code requires block to make sure that the definition will be before any generated code. (Also, remember that to override a function inside a name space in C++, you have to put it inside the namespace like I did. aka defining it like : yy::yylex() won’t work).Note: in (2) we wrote parser:: because yylex function belongs to the class parser (not a namespace!!) As you can remember from the C API, we have yyerror function but we don’t have to rewrite the signature of it because it will be generated anyway and we just have to write the impelementation as said in (3). Now we have to define the tokens and using %token and rewrite the names of the ones which have a type to specify the type to Bison using %type &lt;some_type_name&gt;. Now as we said in the first point, there will be a constructor for each type with a prameter of its type. (we will use this soon don’t worry). In the grammar rules section, I declared an empty rule for Program so that the parser will have a starting point (Note that always there should be such rule, otherwise the parser mostly will return a syntax error and won’t run from the first place)Now inside Parser.tab.hpp there’s : static symbol_type make_IDENT (const std::string&amp; v){ return symbol_type (token::IDENT, v);} This is a generated function which returns a type called symbol_type which Bison understands and supports for applying its grammar but as you can see, we should give it a string as a parameter (which is passed by a const refrernce of course since it’s faster). Also, notice that it sends something else in addition to the string:token::IDENT where token is an enum and IDENT is one of the values which that enum can take. There are similar functions and enum values for the other tokens VAR, INT, IS but for example we have: static symbol_type make_VAR (){return symbol_type (token::VAR);} We don’t have a parameter and it only keeps the enum inside the symoble info (calling symbol_type constructor with 1 parameter) because we don’t have a type attached to this token so that’s all Bison needs in this case.Now it’s time to integrate our Bison parser with our C++ scanner using the make_ methods in addition to using the correct way to define and override the parser class function.The scanner will have this code : (comments might be repeated for the final version and for better understanding)#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include \"parser.tab.hpp\"// I know that global variables are often bad. Forgive me I wanna just explain the idea ((std::ifstream fin;yy::parser::symbol_type get_next_token(){ std::string s; char c; while (true) { // could be done better but organized it like this to edit only assignments and returns when using Bison API if (!fin.eof()) fin.get(c);// get one character else // return the end of the file so the parser will stop return yy::parser::make_YYEOF(); if (c == ' ' || c == '\\n' || fin.eof()) { if (s.empty()) // we only have this character { if (fin.eof()) return yy::parser::make_YYEOF(); //otherwise go and see what's next return get_next_token(); } else { if (!fin.eof()) { // now we need to put the pointer exactly after the word (undo the last step) fin.unget(); } if (s == \"var\") // the last word is var return yy::parser::make_VAR(); if (s == \"integer\") return yy::parser::make_INT(); if (s == \"is\") return yy::parser::make_IS(); if (!s.empty())// it means it is some identifier name return yy::parser::make_IDENT(s); // don't forget to pass the identifier name stored in the string } } else if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || c == '_') // reading some name { s += c; // add the char to the string } else { // we don't know what's that so return undefined token return yy::parser::make_YYUNDEF(); } }}int main(){ fin.open(\"input.txt\"); yy::parser p;\tp.parse(); return 0;}namespace yy{ parser::symbol_type yylex() { return get_next_token(); }}and for the parser code :%require \"3.2\"%language \"C++\"%define api.value.type variant%define api.token.constructor%define parse.assert%code requires{ #pragma once #include &lt;iostream&gt; #include &lt;string&gt; // forward decleration (1) namespace yy { class parser; }}%code{ namespace yy { parser::symbol_type yylex(); // override (2) // no need to override the error function because it is already waiting for our implementation (3) } /* because this function is in the main cpp file, we have to tell the compiler that its definition is outside so that Bison won't also generate an implementation by itself. */ extern yy::parser::symbol_type get_next_token();}%token IDENT VAR INT IS%type &lt;std::string&gt; IDENT%%Program:|Program VariableDeclaration;VariableDeclaration: VAR IDENT IS INT { std::cout &lt;&lt; \"defined an int variable \" &lt;&lt; $2 &lt;&lt; \"\\n\"; /* now we will print what we have */ };%%namespace yy{ void parser::error(const std::string&amp; msg) //(3+) { std::cout&lt;&lt; \"syntax error!\\n\"; }}You can find all the final code examples here.Further Reading: Bison Documentation. My parser for an imperative programming language (it is C++ Scanner using Bison’s C API but it would be useful to read). Flex &amp; Bison: Text Processing Tools 1st Edition bookby John Levine." }, { "title": "Using Bison C API With Hand-written Scanner", "url": "/posts/HAND_WRITTEN_SCANNER_WITH_BISON_C_API/", "categories": "Compilers, Bison", "tags": "C, Bison", "date": "2020-10-18 12:00:00 +0300", "snippet": "You may have a compilers course and wanna learn how to use Bison with your other code. When I had this course I got in a big confusion while trying to use Bison with a Hand Written parser (in my opinion documentation isn’t easy for a bachelor and the deadline won’t wait for you to read all of it). As a result, I had to ask people just to know how to make Bison use my functions instead of Flex’s (most code on internet Flex is used). Well, I finished the course (with not much disaster, thank God) and wanted to write here about it !Let’s start with a brief introduction to be sure that we are on the same page. Compiler Construction consists of the following stages: Token producer or Scanner Parser Parsing Tree Design (just design) Construction and adding nodes to the tree Semantics (make sure an expression is valid for example) Machine Code generation (LLVM code for example)Note : In my case it was a compiled langauge so if you are doing an interpreter, some things will be different for you. Use linux or linux shell on windows because latest Bison is not supported for windows. Install the latest version from here not from package manager. because sometimes it doesn’t install the latest one for some reason…. Let’s say we only have this rule/case (any variable name with letters and underscores works)var some_variable is integer A dummy Scanner just to explain the idea :#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;FILE* fptr;// returns 0 when the file is completely readint get_next_token(){ char s[1002], c; int len = 0; while(1) { c = getc(fptr); if(c == ' ' || c == '\\n' || c == EOF) { if(len == 0) // we only have this character { if(c == EOF) return 0; // we can print it printf(\"%c\",c); return 1; } else { // add NULL termination at the end so that strcmp will know the ending of our array s[len] = '\\0'; if(strcmp(s,\"var\") == 0) // the last word is var printf(\"VAR\"); else if(strcmp(s,\"integer\") == 0) printf(\"INT\"); else if(strcmp(s,\"is\") == 0) printf(\"IS\"); else if(len &gt; 0)// it means it is some identifier (if there's misplacment the grammar will discover it :D ) printf(\"IDENT\"); // now we need to put the pointer exactly after the word (undo last step to reread ONLY the 'non letter or underscore') ungetc(c, fptr); //reset the char array memset(s, 0, sizeof(s)); len = 0; return 1; } } else if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || c == '_') // reading some name { s[len++] = c; } else { printf(\"%s + Unknown symbol! \", s); //reset the char array memset(s, 0, sizeof(s)); len = 0; // stop everything return 0; } }}int main(){ fptr = fopen(\"input.txt\", \"r+\"); while(get_next_token() != 0); printf(\"\\n\"); return 0;} Now the Bison part. I won’t go deep into grammar rules and the way you design them (I learned grammar in Theoretical Computer Science course) but I will talk about the programming aspects. Bison file consists of 4 parts : Defines and requirements (statements start with % usually) C code part(s) for includes and signatures (will be at the beginning of the generated .h file) Grammar part Function defintions part Let’s take a look at this example and I will explain it after that :%require \"3.2\"%define api.pure full%code requires{ // note that these are imported at the beginning of parser.tab.h in the generated C file // so you might not need it (in my case I don't but just to clarify)}%code{ int yylex(YYSTYPE *lvalp); void yyerror(const char *error); // note that this is added after including parser.tab.h in parser.tab.c #include&lt;stdio.h&gt; #include&lt;string.h&gt; // TODO delete int temp = 1;}%token IDENT VAR INT IS%union { // put all the types you want to use here with any identical name // then in types section put its name such as 'st' below char st[1002];}%type&lt;st&gt; IDENT%%VariableDeclaration: VAR IDENT IS INT { /* this is called a semantic action*/ printf(\"defined a variable %s with type int\\n\", $2); };%%void yyerror(const char *error){ printf(\"Syntax Error\\n\");}int yylex(YYSTYPE *lvalp){ return YYEOF;} The first line holds a condition of the least required version of Bison to run our file. The second line declares that we want to use our own scanner (pure calling). Take a look at this link (don’t worry about understanding it 100%). Code-requires and Code blocks. Terminal tokens which don’t have a rule so they can be used as the building blocks for other rules (you can put non terminal token in a rule but at the end, a non terminal token should have only terminal tokens in its grammar directly or in the grammar of its grammar non terminal tokens). Union, which contains a variable to each type we want to return with a unique name for each and Bison will generate them as data members to lvalp in yylex function. %type declares that a token can return that type. The type is named as the identifier name used in the %Union. You don’t have to put types to all terminal tokens and you can add a type to a non-terminal token but don’t forget to put $$ = some_value in the semantic action in each rule of its grammar. In general, Bison has 3 important functions: yylex(lvalp) which is similar in logic to our get_next_token except that you have to return predefined token (we will see them in a little bit) and if you have a token which corresponds to a value, you have to put its value inside lvalp member. In our case, if we see an identifier, we should copy its name to lvalp-&gt;st since st is in the union. For the defined tokens, if you generate .c and .h files from this bison using : Bison -d file_name.y then you can see at the beginning : enum yytokentype { YYEMPTY = -2, YYEOF = 0, /* \"end of file\" */ YYerror = 256, /* error */ YYUNDEF = 257, /* \"invalid token\" */ IDENT = 258, /* IDENT */ VAR = 259, /* VAR */ INT = 260, /* INT */ IS = 261 /* IS */ }; Well, yylex(YYSTYPE lvalp) returns one of these enum values and knows which value to get from lvalp when we return IDENT for example because in Bison we wrote that the type of IDENT is st which is a char array. You can add more parameters using: %param {name_of_parameter} at the beginning. yyparse() which keeps calling yylex() until it returns YYEOF, YYERROR or YYUNDEF. You can add more parameters using: %parse-param {name_of_param} at the beginning. yyerror(char* error_message) which gets called when yylex returns YYUNDEF. To know how to modify the error message, check this. Since some tokens have values (IDENT in our case), we can access these value using I have missed an important thing in Bison, which is not adding a rule for the empty case (because it works for this example only). Therefore, running this bison will print syntax error (supposing that you will add a main function and call yyparse() from there). So don’t forget to do that when you are writing a real parser. I suggest that you stop here and try to modify our get_next_token() such that we can do this in Bison : int yylex(YYSTYPE *lvalp) { return get_next_token(lvalp); } Don’t forget to add the line : int get_next_token(YYSTYPE *lvalp); in the code block. And try to make it do the job. After changing yylex and adding the signature of get_next_token in the previous step, we will modify our scanner.cpp file so that it would work with the parser:#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;// include parser header so we can use the enums#include \"parser.tab.h\"FILE* fptr;// returns 0 when the file is completely readint get_next_token(YYSTYPE *lvalp){ char s[1002], c; int len = 0; while(1) { c = getc(fptr); if(c == ' ' || c == '\\n' || c == EOF) { if(len == 0) // we only have this character { if(c == EOF) return YYEOF; //otherwise return the next token because there's no enum for new lines or spaces return get_next_token(lvalp); } else { // add NULL termination at the end so that strcmp will know the ending of our array s[len] = '\\0'; if(strcmp(s,\"var\") == 0) // the last word is var return VAR; else if(strcmp(s,\"integer\") == 0) return INT; else if(strcmp(s,\"is\") == 0) return IS; else if(len &gt; 0)// it means it is some identifier (if there's misplacment the grammar will discover it :D ) { // put the value and return the correct token strcpy(lvalp-&gt;st, s); return IDENT; } // now we need to put the pointer exactly after the word (undo last step to reread ONLY the 'non letter or underscore') ungetc(c, fptr); //reset the char array memset(s, 0, sizeof(s)); len = 0; // go to the next one return get_next_token(lvalp);; } } else if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || c == '_') // reading some name { s[len++] = c; } else { //reset the char array memset(s, 0, sizeof(s)); len = 0; // stop everything return YYUNDEF; } } return YYUNDEF;}int main(){ fptr = fopen(\"input.txt\", \"r+\"); int x = yyparse(); printf(\"\\n%d\", x); return 0;}For easier compliation use a make file :example: Scanner.c Parser.y \tbison -d Parser.y\tgcc Scanner.c Parser.tab.c -o programNow running make then ./program, gives the following output:defined a variable x with type intYou can try different variable names or mess up the code sample to get a syntax error.I hope this was a useful tutorial and now you know how to use Bison with your hand written scanner.You can find all the final code examples here.Final Note:There’s a Bison C++ API which allows you to use dynamic types such as std::string. I will write about it in another post. You can use C API with C++ scanner but you have to use a pointer to the std::string and other things such as std::shared_pointer will be really difficult to use here.Further Reading: Bison Documentation. My parser for an imperative programming language (it is C++ Scanner using Bison’s C API but it would be useful to read). Flex &amp; Bison: Text Processing Tools 1st Edition bookby John Levine." } ]
