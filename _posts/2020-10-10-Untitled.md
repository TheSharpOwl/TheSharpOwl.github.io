---
title: Test
date: 2020-10-17 13:00:00 +/-0800
categories: [Compilers, Bison]
tags: c
---
You may have a compilers course and wanna learn how to use Bison with your other code. When I had this course I got in a big confusion while trying to use Bison with a Hand 
Written parser (in my opinion documentation isn't easy for a bachelor and the deadline won't wait for you to read all of it). As a result, I had to ask people just to know how to make Bison use my functions instead of Flex's (most code on internet Flex is used). Well, I finished the course (with not much disaster, thank God) and wanted to write here about it !

Let's start with a brief introduction to be sure that we are on the same page. **Compiler Construction consists of the following stages:**

1. Token producer or Scanner
2. Parser
3. Parsing Tree Design (just design)
4. Construction and adding nodes to the tree
5. Semantics (make sure an expression is valid for example)
6. Machine Code generation (LLVM code for example)


**Note : In my case it was a compiled langauge so if you are doing an interpreter, some things will be different for you**

1. Use linux or linux shell on windows because latest Bison is not supported for windows.<br>

2.  **[Install the latest version from here](https://launchpad.net/bison/head/3.7.2) not from package manager**. because sometimes it doesn't install the latest one for some reason....

3. Let's say we only have this rule/case :
```
var some_variable is integer
```

4. A dummy Scanner just to explain the idea : 

```
#include <stdio.h>
#include <stdlib.h>
#include<string.h>

int main()
{
   FILE* fptr;
   fptr = fopen("input.txt", "r");

   if(fptr == NULL)
   {
       printf("Error reading the file!\n");
       exit(1);
   }
   char c = ' ';
   char s[1002]; // let's suppose this length for a word is enough for now
   int len = 0;
   while(1)
   {
       c = fgetc(fptr);
        if(c == ' ' || c == '\n' || c == EOF) // if the word is finished
        {
            // add NULL termination at the end so that strcmp will know the ending of our array
            s[len] = '\0'; 

            if(strcmp(s,"var") == 0) // the last word is var
                printf("VAR");
            else if(strcmp(s,"integer") == 0)
                printf("INT");
            else if(strcmp(s,"is") == 0)
                printf("IS");
            else if(len > 0)// it means it is some identifier (we don't care about misplacment for now)
                printf("IDENT");

            if(c != EOF)
                printf("%c",c);
            else
                break;
            //reset the char array
            memset(s, 0, sizeof(s));
            len = 0;

        }
        // if we have a letter then add it until we get to case 1 (space or new line)
        else if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) 
        {
            s[len++] = c;
        }
        else
        {
            // we won't stop if we find, just warn the user about it (we have a use of this in the next stage)
            printf("%s + Unknown symbol! ", s);
            //reset the char array
            memset(s, 0, sizeof(s));
            len = 0;
        }    
   }

   fclose(fptr);
   printf("\n");
    return 0;
}
```

To be continued... 